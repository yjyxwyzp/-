杭电oj做到了最大子序列和，自己的换了好多方法都超时了，网上一查需要用到动态规划，趁此机会学习一下动态规划
但是感觉动态规划有点像这个递归哈哈哈哈

1.动态规划，就是利用历史记录来避免计算的重复，而这些历史记录我们需要一些变量来保存,一般用到一维数组还有二维数组来保存

2.三个步骤
（1） 定义数组元素的含义，例如你的dp【i】代表的什么含义
（2）找出数组元素之间的关系式，有点类似高中所学的数学归纳法，都是通过已知元素来推未知元素
（3）找出初始值，学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，
但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，，
所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值而这，就是所谓的初始值。由了初始值，并且有了数组元素之间的关系式
，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。

3.
(1)例题.一维DP
 问题描述，一只青蛙一次可以跳上一级台阶，也可以跳上二级台阶。求台阶跳上一个n级台阶总共有多少种方法。
 
 三大步骤。
 一.定义dp的含义，我们的问题是跳上n级台阶时的跳法，我们就定义dp【i】的含义是跳上一个n级台阶总共有dp【i】种跳法。
 
 二.找出元素之间的关系式，因为在每一阶台阶时都是从n-1阶还有n-2阶台阶跳上来的
 由于我们要算所有可能的跳法，所以有dp【i】=dp【i-1】+dp【i-2】；
 
 三.找出初始条件
 当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，
 我们必须要直接给出它的数值，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：
dp[0] = 0.
dp[1] = 1.
即 n <= 1 时，dp[n] = n.
代码
  int[] dp = new int[n+1];
    // 给出初始值
    dp[0] = 0;
    dp[1] = 1;
    // 通过关系式来计算出 dp[n]
    for(int i = 2; i <= n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    
 （2）例题二    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
